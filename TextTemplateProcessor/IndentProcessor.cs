namespace TextTemplateProcessor
{
    using global::TextTemplateProcessor.Core;
    using global::TextTemplateProcessor.Interfaces;
    using static global::TextTemplateProcessor.Core.Messages;

    /// <summary>
    /// The <see cref="IndentProcessor" /> class is used for managing the line indentation for text
    /// lines that are generated by the Text Template Processor.
    /// </summary>
    internal class IndentProcessor : IIndentProcessor
    {
        private const int DefaultTabSize = 4;
        private const int MaxIndentValue = 9;
        private const int MaxTabSize = 9;
        private const int MinIndentValue = -9;
        private const int MinTabSize = 1;
        private bool _isCurrentStateSaved = false;
        private int _saveCurrentIndent = 0;
        private int _saveTabSize = 0;

        /// <summary>
        /// A constructor that creates an instance of the <see cref="IndentProcessor" /> class and
        /// initializes its dependencies.
        /// </summary>
        /// <param name="logger">
        /// A reference to a logger object used for logging messages.
        /// </param>
        /// <param name="locater">
        /// A reference to a locater object used for keeping track of the current location being
        /// processed in the text template file.
        /// </param>
        /// <exception cref="ArgumentNullException">
        /// Exception is thrown if any of the dependencies passed into the constructor are
        /// <see langword="null" />.
        /// </exception>
        internal IndentProcessor(ILocater locater, ILogger logger)
        {
            Utility.NullDependencyCheck(logger,
                                        ClassNames.IndentProcessorClass,
                                        ServiceNames.LoggerService,
                                        ServiceParameterNames.LoggerParameter);

            Utility.NullDependencyCheck(locater,
                                        ClassNames.IndentProcessorClass,
                                        ServiceNames.LocaterService,
                                        ServiceParameterNames.LocaterParameter);

            Logger = logger;
            Locater = locater;
            CurrentIndent = 0;
            TabSize = DefaultTabSize;
        }

        /// <summary>
        /// Gets the current indent value.
        /// </summary>
        /// <remarks>
        /// The value returned is the number of tabs that will be inserted at the beginning the next
        /// generated text line.
        /// </remarks>
        public int CurrentIndent { get; private set; }

        /// <summary>
        /// Gets the current tab size.
        /// </summary>
        /// <remarks>
        /// The value returned is the number of spaces in a single tab.
        /// </remarks>
        public int TabSize { get; private set; }

        private ILocater Locater { get; init; }

        private ILogger Logger { get; init; }

        /// <summary>
        /// Determines the first time indent value for the given text item.
        /// </summary>
        /// <param name="firstTimeOffset">
        /// The first time indent offset value.
        /// </param>
        /// <param name="textItem">
        /// The text item for the current text line being processed.
        /// </param>
        /// <returns>
        /// The calculated indent value for the current text line.
        /// </returns>
        /// <remarks>
        /// If the <paramref name="firstTimeOffset" /> value is zero, then this method will return
        /// the indent value as determined by the <see cref="GetIndent(TextItem)" /> method.
        /// </remarks>
        public int GetFirstTimeIndent(int firstTimeOffset, TextItem textItem)
        {
            int indent = CurrentIndent;

            if (firstTimeOffset is not 0)
            {
                indent += firstTimeOffset * TabSize;

                if (indent < 0)
                {
                    Logger.Log(MsgFirstTimeIndentHasBeenTruncated,
                               Locater.CurrentSegment);
                    indent = 0;
                }

                CurrentIndent = indent;
            }
            else
            {
                indent = GetIndent(textItem);
            }

            return indent;
        }

        /// <summary>
        /// Determines the correct indent value for the given text item.
        /// </summary>
        /// <param name="textItem">
        /// The text item for the current text line being processed.
        /// </param>
        /// <returns>
        /// The calculated indent value for the current text line.
        /// </returns>
        public int GetIndent(TextItem textItem)
        {
            int indent = CurrentIndent;

            if (textItem.IsRelative)
            {
                indent += textItem.Indent * TabSize;
            }
            else
            {
                indent = textItem.Indent * TabSize;
            }

            if (indent < 0)
            {
                Logger.Log(MsgLeftIndentHasBeenTruncated,
                           Locater.CurrentSegment);
                indent = 0;
            }

            if (!textItem.IsOneTime)
            {
                CurrentIndent = indent;
            }

            return indent;
        }

        /// <summary>
        /// Determines whether or not the given string value represents a valid integer indent
        /// value.
        /// </summary>
        /// <param name="stringValue">
        /// The string representation of an indent value.
        /// </param>
        /// <param name="indent">
        /// The integer value that gets parsed from the <paramref name="stringValue" /> parameter.
        /// </param>
        /// <returns>
        /// <see langword="true" /> if the <paramref name="stringValue" /> was successfully
        /// converted to a valid indent value. Otherwise, returns <see langword="false" />.
        /// </returns>
        /// <remarks>
        /// The <paramref name="indent" /> parameter will be set to 0 if
        /// <paramref name="stringValue" /> can't be converted to a valid indent value.
        /// </remarks>
        public bool IsValidIndentValue(string stringValue, out int indent)
        {
            if (int.TryParse(stringValue, out int indentValue))
            {
                if (indentValue is < MinIndentValue or > MaxIndentValue)
                {
                    Logger.Log(MsgIndentValueOutOfRange,
                               indentValue.ToString());
                }
                else
                {
                    indent = indentValue;
                    return true;
                }
            }
            else
            {
                Logger.Log(MsgIndentValueMustBeValidNumber,
                           stringValue);
            }

            indent = 0;
            return false;
        }

        /// <summary>
        /// Determines whether or not the given string value represents a valid integer tab value.
        /// </summary>
        /// <param name="stringValue">
        /// The string representation of the tab value.
        /// </param>
        /// <param name="tabSize">
        /// The integer value that gets parsed from the <paramref name="stringValue" /> parameter.
        /// </param>
        /// <returns>
        /// <see langword="true" /> if the <paramref name="stringValue" /> parameter was
        /// successfully converted to a valid tab size value.
        /// </returns>
        /// <remarks>
        /// The <paramref name="tabSize" /> will be set to 0 if <paramref name="stringValue" />
        /// can't be converted to a valid tab size value.
        /// </remarks>
        public bool IsValidTabSizeValue(string stringValue, out int tabSize)
        {
            if (int.TryParse(stringValue, out int tabValue))
            {
                if (tabValue is < MinTabSize or > MaxTabSize)
                {
                    Logger.Log(MsgTabSizeValueOutOfRange,
                               tabValue.ToString());
                }
                else
                {
                    tabSize = tabValue;
                    return true;
                }
            }
            else
            {
                Logger.Log(MsgTabSizeValueMustBeValidNumber,
                           stringValue);
            }

            tabSize = 0;
            return false;
        }

        /// <summary>
        /// Resets the current indent value to zero and sets the tab size to the default value.
        /// </summary>
        public void Reset()
        {
            CurrentIndent = 0;
            TabSize = DefaultTabSize;
        }

        /// <summary>
        /// Restores the current indent and tab size from the saved values.
        /// </summary>
        /// <remarks>
        /// This method exits without doing anything if the current indent and tab size wasn't
        /// previously saved.
        /// </remarks>
        public void RestoreCurrentState()
        {
            if (_isCurrentStateSaved)
            {
                CurrentIndent = _saveCurrentIndent;
                TabSize = _saveTabSize;
                _isCurrentStateSaved = false;
            }
        }

        /// <summary>
        /// Save the current indent and tab size so that they can be restored later.
        /// </summary>
        public void SaveCurrentState()
        {
            _saveCurrentIndent = CurrentIndent;
            _saveTabSize = TabSize;
            _isCurrentStateSaved = true;
        }

        /// <summary>
        /// Set the tab size to the specified value.
        /// </summary>
        /// <param name="tabSize">
        /// The new value for the tab size.
        /// </param>
        /// <remarks>
        /// The tab size will be constrained to fall within the minimum and maximum values defined
        /// in the <see cref="IndentProcessor" /> class definition.
        /// </remarks>
        public void SetTabSize(int tabSize)
        {
            if (tabSize < MinTabSize)
            {
                Logger.Log(MsgTabSizeTooSmall,
                           MinTabSize.ToString());
                TabSize = MinTabSize;
            }
            else if (tabSize > MaxTabSize)
            {
                Logger.Log(MsgTabSizeTooLarge,
                           MaxTabSize.ToString());
                TabSize = MaxTabSize;
            }
            else
            {
                TabSize = tabSize;
            }
        }
    }
}