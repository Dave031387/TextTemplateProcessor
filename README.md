# Text Template Processor
## Overview
***Text Template Processor*** is a class library written in C# 12 and .NET 8 that allows you to easily create console applications for processing text
template files and generating new text files from those templates. The library implements the following features:

- Control of the indentation of each generated text line (see the section covering [Text Lines](#text-lines).)
- Support for named tokens that act as placeholders for generated text (see the section covering [Tokens](#tokens).)
- Template files are made up of named blocks of text lines (called *Segments*) that are logical units that can be pieced together in any order to
  generate the final output file (see the section on [Segment Header Lines](#segment-header-lines).)
- A special *Segment* called a *Pad Segment* can be defined to be automatically placed between consecutive occurrences of the same named *Segment*
- Special handling of the indentation of the first line of a *Segment* the first time that *Segment* is processed. This is called a "first time
  indent". (This and the *Pad Segment* are covered in the section on [Segment Options](#segment-options).)
- Extensive validation of the text template file to ensure it is valid and usable
- Detailed informational, warning, and error messages (messages are displayed in a *Console* window)

These features will be described in much more detail in the sections that follow.

## Public Classes
The ***Text Template Processor*** class library contains a single public class that can be used for creating your specific text template processor
application.

- ***TextTemplateConsoleBase*** - This is an abstract base class. It contains all the functionality needed for processing text template files and
  generating new files from the template. This is the class from which you must derive your custom text template processor class.
  (see [***TextTemplateConsoleBase***](#texttemplateconsolebase-class) class later in this document)

## Internal Classes
The following classes are defined as internal to the class library. They provide the underlying functionality to support the public class described
above. You never need to access any of these classes directly in your code. They are listed here only to give you an idea of what went into the design
of this class library.

- ***FileAndDirectoryService*** - This class handles all I/O for the ***Text Template Processor*** class library, including creating directories,
  reading, writing, and deleting text files, etc.
- ***PathValidater*** - This class is used for validating file and directory path strings to ensure they're valid.
- ***TextReader*** - This class manages the reading of text files. (The actual reading is performed by the ***FileAndDirectoryService*** class.)
- ***TextWriter*** - This class manages the writing of text files (the actual writing is performed by the ***FileAndDirectoryService*** class.)
- ***ConsoleLogger*** - All informational, warning, and error messages generated by the ***Text Template Processor*** class library are routed through
  this class.
- ***ConsoleReader*** - Displays a prompt on the *Console* and then retrieves the user response to that prompt.
- ***ConsoleWriter*** - Writes text lines to the *Console*.
- ***MessageWriter*** - Formats messages and then calls the ***ConsoleWriter*** class to write the messages to the *Console*.
- ***Locater*** - This class is shared by many of the other classes described here. It is used for keeping track of the current location in the text
  template file that is being processed.
- ***TemplateLoader*** - This class manages the reading, parsing, and validation of the text template file.
- ***SegmentHeaderParser*** - Parses and validates segment header lines in the text template file and saves the segment names and segment options for
  later use during the file generation process.
- ***TextLineParser*** - Parses and validates text lines in the text template file and saves the indent control information and text for each line for
  later use during the file generation process.
- ***TokenProcessor*** - Parses and validates the tokens contained on the text lines in the text template file and saves the token names. This class
  is also responsible for replacing tokens with generated text during the file generation process.
- ***NameValidater*** - Validates *Segment* names and token names to ensure that they are valid.
- ***DefaultSegmentNameGenerator*** - Used for generating default names for *Segments* whose names are either missing or invalid in the text template
  file.
- ***IndentProcessor*** - Maintains the proper indentation of generated text lines based on the *First Time Indent* option that was retrieved from the
  segment headers and the tab control information found on the text lines of the text template file.
- ***ServiceLocater*** - This class implements a basic *Inversion of Control* container used for resolving class dependencies in the ***Text Template
  Processor*** class library. It uses the [***BasicDI***](https://github.com/Dave031387/BasicDI) package.

## Package Dependencies
The ***Text Template Processor*** class library is dependent upon two other packages which were also created by the author of this library.

- The ***BasicDI*** package is used for handling inversion of control and dependency injection. This package can be found at
  https://github.com/Dave031387/BasicDI
- The ***MockMethodCallOrderVerifier*** package is used by the unit test classes to verify the order of mock method calls made during each unit test.
  This package can be found at https://github.com/Dave031387/MockMethodCallOrderVerifier

## Template Files
### Introduction
A template file is a specially formatted text file that can be used as a "blueprint" for generating other text files. In the case of the ***Text
Template Processor*** class library, the template files are made up of one or more *Segments*. Each *Segment* begins with a segment header line
followed by one or more text lines. A text line can contain zero or more named token placeholders. Each named token is replaced with the appropriate
text value when the output file is being generated.

### Template File Layout
Each line in a template file must adhere to the following format:

```
C C C   R R R ...
1 2 3 4 5 6 7 ...
```

The first three character positions of each line (the *"CCC"*) must contain a valid text template control code (see [Template Control
Codes](#template-control-codes), below). The fourth character position must be blank. The remainder of the line (the *"RRR..."*) depends on the type
of control code used. There are three possibilities:

- For comment lines, the remainder of the line contains the comment. (see [Comment Lines](#comment-lines))
- For segment header lines, the remainder contains the segment name (must start in column 5) followed by zero or more optional segment options (see
  [Segment Header Lines](#segment-header-lines) and [Segment Options](#segment-options)).
- For text lines, the remainder of the line contains the tokenized text that will be used to generate the output files. The fifth character position
  on the text template line is the first character position of the generated text line, and so on. (see [Text Lines](#text-lines) and
  [Tokens](#tokens))

### Template Control Codes
As mentioned above, each line in a text template file must start with a 3-character control code located in the first three character positions of the
line. (There is one exception, described later.) The first two control codes are these:

- `///` - This control code (three slashes) starts a comment line.
- `###` - This control code (three hash symbols) starts a segment header line.

Each text template line begins with a tab control code which affects the indentation of the generated text line. The code is made up of three
characters:

- The first character must be `@` (normal tab) or the letter `O` (one-time tab). This character defines whether the specified tab amount on this line
  carries over to the next line (normal tab) or if it only applies to the current line (one-time tab).
- The second character must be one of the characters `-` (back tab), `+` (forward tab), or `=` (specify the exact tab amount). The first two are
  called "relative" since they are taken relative to the current tab position. The third one is called "absolute" since it is always taken from the
  left margin.
- The last character must be a number between 0 and 9. This specifies the number of tabs used in calculating the new tab position.

Often you may want the indentation of one text line to remain unchanged from the previous text line. In this case you could use the control codes
`@+0` or `@-0`, which say to tab 0 from the right or left of the current tab position, effectively leaving the indentation unchanged from the previous
line. Since many, if not most, of the text lines in a typical template file would probably be of this type, the ***Text Template Processor*** class
library allows you to leave the control code blank on these lines. Whenever it comes across a text line having nothing in the first three character
positions, it assumes that the text line is to be indented the same amount as the most recent text line having a "normal" (as opposed to "one-time")
tab control code.

> [!IMPORTANT]
> *This is the only instance in which it is okay to omit the control code. All other lines in the text template file must have a valid control code in
> the first three character positions of the line.*

### Comment Lines
Template lines that begin with `///` are considered to be comment lines. These lines can appear anywhere in a text template file. These lines are
essentially ignored by the ***Text Template Processor***. As such, comment lines serve no purpose other than as documentation for the user of the text
template file.

The following example shows a valid comment line.

```
/// This is a comment.
```

> [!CAUTION]
> *Comments are only allowed on lines that start with the comment control code (the three slashes). There is no option, neither does it make sense, to
> add a comment to the end of a segment header line or text line. Doing so will either result in errors when the text template file is parsed, or
> unexpected output when the generated text file is generated.*

### Segment Header Lines
Template lines that begin with `###` are considered to be segment header lines. The segment header denotes the beginning of a *Segment* in the text
template file and it must be followed by one or more text lines that make up that segment. The segment header must adhere to the following format:

```
### SegmentName [zero or more segment options]
123456789...
```

As already mentioned, the three hash characters must appear in the first three character positions, and the fourth character position must be blank.
The segment name must start in the fifth character position. Together, these constitute the minimum requirements of a segment header line.

Optionally, you can include one or more segment options after the segment name. At least one space must appear between the segment name and the first
segment option. Subsequent segment options must be separated from each other by one or more spaces and/or commas.

### Segment Options

The format of a segment option must adhere to the following format:

```
OptionName=OptionValue
```

The option name must be followed immediately by an equals sign with no intervening spaces, and then the value assigned to that option must immediately
follow the equals sign, again with no intervening spaces.

There are three segment options available in the current version of the ***Text Template Processor*** class library. These are:

- `TAB` - This option changes the tab size value. The tab size gives the number of space characters that make up a single tab. For example, if the
  **TAB** option is set to 3 and the next text line to be processed in the segment specifies a tab value of 2, then that text line will be indented 6
  spaces (3x2) from the current tab position. The value assigned to the **TAB** option must be a number between 1 and 9.
- `FTI` - This is the *First Time Indent* option. A *Segment* may be processed multiple times when generating a single text output file. The *First
  Time Indent* option overrides the tab control code of the first text line of the segment the first time that the segment is processed. The value
  assigned to this option must be a number between -9 and -1 (left tab), or between 1 and 9 (right tab).

  > [!NOTE]
  > *The **FTI** tab value is always treated as a "normal" tab control code (as opposed to a "one-time" tab control code). For example, the option
  > **"FTI=-1"** would be handled the same as the tab control code **"@-1"**.*

- `PAD` - When a particular *Segment* (the "active" *Segment*) is processed two or more times consecutively, sometimes it's nice to be able to
  insert padding (typically one or more blank lines) between each occurrence of the active *Segment* in the output file. The **PAD** option allows you
  to do that. The value assigned to this option must be the name of a segment that appears earlier in the text template file than the active
  *Segment*. This earlier segment is referred to as the *Pad Segment*. The text lines in the *Pad Segment* will automatically be inserted just before
  the text lines of the active *Segment* on the second and subsequent times that the active *Segment* is processed.

Segment options can appear in any order on a segment header line. The following example shows a segment header line which makes use of all three
segment options. (Assumes a *Segment* named *PadSegment* has been defined earlier in the text template file.)

```
### Segment1 TAB=3, FTI=1, PAD=PadSegment
```
<br>

> [!CAUTION]
> *Assigning 0 (zero) to the **FTI** option effectively disables the First Time Indent processing for that segment. In this case the **FTI** option
> will be ignored and the first text line of the segment will always be indented according to the tab control code on that text line.*

> [!NOTE]
> *A given segment option must appear only once on a segment header line. If an option appears more than once, only the first occurrence of that
> option will be used. All other occurrences will be ignored.*

> [!NOTE]
> *If a segment specifies the **PAD** option then that segment can't itself be specified as a pad segment for some other segment. In other words,
> nesting of padded segments is not allowed.*

### Text Lines
Text lines define the layout of the text that gets written to the generated output file. The text on a text line will be written verbatim to the
output file after applying the appropriate indentation and after replacing all tokens with their corresponding token values. ([Tokens](#tokens) will
be covered later in this document.) The amount of indentation depends on the current indent amount carried forward from the previous text line and the
tab value specified in the tab control code of the current text line.

> [!NOTE]
> *The current indent amount always gives the number of space characters to be inserted at the start of a generated text line. This is different than
> the tab value specified in the tab control code of a text line, which gives the number of tabs which will be added or removed from the current
> indent amount to arrive at the new current indent amount.*

The current indent amount always starts at 0 (zero) at the beginning of the text template process. It may or may not get adjusted when a text line is
processed, depending on the nature of the tab control code at the start of the text line. One-time tab control codes (with the letter `O` in the first
character position) never alter the current indent amount. The current indent amount also remains unchanged if the tab control code is three spaces.

Normal tab control codes (with `@` in the first character position) will affect the current indent as explained below. (The current tab size value in
each of the following examples is assumed to be 2 and the current indent amount is assumed to be 6.)

- `@+1` - This is a normal right tab control code with a tab value of 1. When this code is processed the current indent amount will be increased from
  6 to 8 spaces (adding 1 tab to the current indent amount).
- `@-2` - This is a normal left tab control code with a tab value of -2. When this code is processed the current indent amount will be decreased from
  6 to 2 spaces (removing 2 tabs from the current indent amount).
- `@=2` - This is a normal absolute tab control code with a tab value of 2. Two tabs contain a total of 4 spaces (tab value of 2 multiplied by the
  current tab size value of 2). The current indent amount will therefore be set to 4 spaces regardless of its current value.

> [!NOTE]
> *The current indent amount can never be less than zero. If a normal left tab control code contains a tab value that would cause the current indent
> amount to go negative, the current indent amount will be set to zero instead.*

The following table shows examples of the various tab control codes along with the impact on the current indent position and the generated text line.
The current indent amount starts at zero with the first text line and is adjusted by the tab control code of each subsequent text line. The tab size
value is assumed to be 2 spaces. The current indent amount, text line indent, and new indent amount columns are all in terms of the number of spaces.
The tab value column is in terms of the number of tabs.

```
   |             | CURRENT |        |             | NEW     |                |
   | TEXT LINE   | INDENT  | TAB    | TEXT LINE   | INDENT  | GENERATED TEXT |
   | 1234567890  | AMOUNT  | VALUE  | INDENT      | AMOUNT  | 12345678901234 |
   | ----------- | ------- | ------ | ----------- | ------- | -------------- |
 1 | @+1 Line 1  |    0    |   +1   | 0+(1x2) = 2 |    2    |   Line 1       |
 2 | O+1 Line 2  |    2    |   +1   | 2+(1x2) = 4 |    2    |     Line 2     |
 3 |     Line 3  |    2    |    0   | 2+(0x2) = 2 |    2    |   Line 3       |
 4 | @-3 Line 4  |    2    |   -3   | 2-(3x2) ->0 |    0    | Line 4         |
 5 | O=3 Line 5  |    0    |   =3   |   (3x2) = 6 |    0    |       Line 5   |
 6 | @+2 Line 6  |    0    |   +2   | 0+(2x2) = 4 |    4    |     Line 6     |
 7 | O-1 Line 7  |    4    |   -1   | 4-(1x2) = 2 |    4    |   Line 7       |
 8 | @-1 Line 8  |    4    |   -1   | 4-(1x2) = 2 |    2    |   Line 8       |
 9 | @=2 Line 9  |    2    |   =2   |   (2x2) = 4 |    4    |     Line 9     |
10 | O-3 Line 10 |    4    |   -3   | 4-(3*2) ->0 |    4    | Line 10        |
```

In the above table, notice that only lines having tab control codes beginning with `@` impact the current indent value. Also notice that in the fourth
line the text line indent and new indent amount values get set to zero because the calculated value (2-(3x2)) would have been negative. The text line
indent on the tenth line is zero for the same reason, although the current indent amount isn't affected since it is a one-time tab control code.
Notice that the new indent amount on one line becomes the current indent amount on the next line.

### Tokens
A token is a named placeholder on a text line. A text line may contain one or more tokens, or no tokens at all. Any tokens on a text line will be
replaced with appropriate text values before the generated text line is written to the output file.

A token must begin with the characters `<#` and end with `#>`. The token name appears between these two delimiters. Zero or more spaces can appear
between the start delimiter and the token name, and between the token name and the end delimiter. Optionally, a "case" indicator character (either `+`
or `-`) can appear immediately after the start delimiter. The following would all be valid tokens according to these rules:

```
<#Name#>
<# Name #>
<#+Name   #>
<#-    Name#>
```

The optional case indicator character can be used to adjust the case of the first character of the token's text value before the text line is written
to the output file. The `+` character causes the first character of the token's text value to be converted to uppercase. The `-` character causes the
first character to be converted to lowercase. Keep in mind that this only affects the first character of the token's text value.

In the following examples assume that the text value for *Token1* is `red` and the text value for *Token2* is `Sal`. Each line in the example shows
the original tokenized text line followed by the same line after the tokens have been replaced by their corresponding text values. Only the text
portion of the text line is displayed. The tab control codes are omitted to simplify things.

```
TEXT LINE                            GENERATED TEXT
-----------------------------------  ------------------
<#Token2#>ly and F<#  Token1 #>      Sally and Fred
F<# Token1 #> is bo<#Token1 #>       Fred is bored
<#+Token1#>o this propo<#- Token2#>  Redo this proposal
```

In the event that you don't want the token start delimiter to be treated as a token delimiter, you must escape it with a backslash character `\`, like
so:

```
TEXT LINE                                  GENERATED TEXT
-----------------------------------------  ----------------------------------
The value of \<#Token1#> is "<#Token1#>".  The value of <#Token1#> is "red".
```

Notice that the backslash escape character is not written to the output file.

The ***Text Template Processor*** class library includes a public method that can be called to change the start and end delimiters and the escape
character if there should be the need to do so. (see [***SetTokenDelimiters***](#settokendelimiters))

### Segment and Token Names
Segment and token names must follow these rules:

1. The name must begin with an upper- or lowercase letter.
1. After the first character, the rest of the name can contain upper- or lowercase letters, the digits 0 through 9, and underscores.
1. The name must not contain spaces.
1. Names containing characters other than those mentioned above are flagged as invalid.
1. Names can be of any length, from one character and upwards. However, it makes sense to keep them as short as possible.

Segment and token names are validated when the text template file is loaded and parsed. Missing or invalid segment names are replaced by a default
name that starts with `DefaultSegment` and ends with a number that gets incremented for each default name that gets used. The first missing or invalid
segment name will be replaced with `DefaultSegment1`, the second with `DefaultSegment2`, and so on.

If a token has an invalid name, then the entire token will be escaped and treated like regular text.

### Sample Text Template File
The following is a sample text template file that demonstrates many of the features described earlier in this document. This template can be used for
generating the syntax for a C# source code file.

```
/// The following is the pad segment which will be used to
/// insert a blank line between occurrences of the PropertySegment.
### PadSegment
    
/// The following segment defines the first lines of
/// the class definition.
### Top
    namespace <#Namespace#>
    {
#+1 public class <#ClassName#>
    {
/// The following segment defines the last lines of
/// the class definition.
### Bottom
@-1 }
@-1 }
/// The following segment defines a property with a
/// backing field.
### Property FTI=1, PAD=PadSegment
    private <#PropertyType#> _<#-PropertyName#>;
    
    public <#PropertyType#> <#+PropertyName#>
    {
@+1 get => _<#-PropertyName#>;
    set => _<#-PropertyName#> = value;
@-1 }
```

Now assume you have created your own app derived from the ***TextTemplateConsoleBase*** class. In that class you perform the following actions:

1. Generate the *Top* segment with the *Namespace* token value set to `MyNamespace` and the *ClassName* token value set to `MyClass`.
1. Generate the *Property* segment with the *PropertyType* token value set to `bool` and the *PropertyName* token value set to `IsChanged`.
1. Generate the *Property* segment with the *PropertyType* token value set to `string` and the *PropertyName* token value set to `firstName`.
1. Generate the *Property* segment with the *PropertyType* token value set to `int` and the *PropertyName* token value set to `Age`.
1. Generate the *Bottom* segment.

Performing these steps in this order will result in the following generated text file being created:

```csharp
namespace MyNamespace
{
    public class MyClass
    {
        private bool _isChanged;

        public bool IsChanged
        {
            get => _isChanged;
            set => _isChanged = value;
        }

        private string _firstName;

        public string FirstName
        {
            get => _firstName;
            set => _firstName = value;
        }

        private int _age;

        public int Age
        {
            get => _age;
            set => _age = value;
        }
    }
}
```

The **FTI** and **PAD** options play a critical role in the proper formatting of this text file. To demonstrate, if we were to remove these options
from the *Property* segment our output would look like the following, which is not at all what we want.

```csharp
namespace MyNamespace
{
    public class MyClass
    {
    private bool _isChanged;

    public bool IsChanged
    {
        get => _isChanged;
        set => _isChanged = value;
    }
    private string _firstName;

    public string FirstName
    {
        get => _firstName;
        set => _firstName = value;
    }
    private int _age;

    public int Age
    {
        get => _age;
        set => _age = value;
    }
}
}
```

There are a couple other things to note in this example:

1. The tab size value defaults to 4 spaces if no tab size is set by the **TAB** option on a segment header, or by the [***SetTabSize***](#settabsize)
   method of the ***TextTemplateConsoleBase*** class.
1. Blank text lines in a text template file can be shortened to 4 characters (the three-character tab control code, and the required space in the
   fourth character position).

## ***TextTemplateConsoleBase*** Class
### Overview
The ***TextTemplateConsoleBase*** class is intended to be used in a console app that is run from within the **Visual Studio IDE**. The class is an
abstract base class from which your custom ***Text Template Processor*** class must derive.

### Constructor
The ***TextTemplateConsoleBase*** class has a single public constructor with the following signature:

```csharp
public TextTemplateConsoleBase()
```

The default constructor takes no arguments. It initializes the class dependencies and then retrieves the directory path of the **Visual Studio**
solution from which the custom ***Text Template Processor*** console app was run. It starts looking in the directory from which the console app was
executed. If it doesn't find a solution file with the `.sln` file name extension, then it looks in the next higher directory level. This continues
until either the solution file is located, or the root directory is reached. The solution directory is saved in the
[***SolutionDirectory***](#solutiondirectory) property.

> [!Important]
> *When searching for the solution directory, any directory containing any file with a name ending in `.sln` will be considered a match, regardless of
> whether or not that file is actually a solution file or not.*

### Properties
#### ***CurrentIndent***

```csharp
int CurrentIndent { get; }
```

The ***CurrentIndent*** property is used to retrieve the current indent amount. This property is initialized to 0 (zero) when the class is
instantiated. The ***CurrentIndent*** then gets updated as the tab control codes are processed in the text template file. The value of this property
will always be a positive number (or zero). See the example in the [*Text Lines*](#text-lines) section earlier in this document.

#### ***CurrentSegment***

```csharp
string CurrentSegment { get; }
```

The ***Text Template Processor*** class library keeps track of which segment it is working on. This happens in two situations. First, when the text
template file is being parsed, the name of the segment that is currently being parsed is stored in the ***CurrentSegment*** property. Then, when the
text output file is being generated, the name of the segment being generated is stored in this property.

#### ***GeneratedText***

```csharp
IEnumerable<string> GeneratedText { get; }
```

As the text output file is being generated, each generated text line is appended to the end of the generated text buffer. The ***GeneratedText***
property returns a copy of the generated text buffer. Note that this is just a copy, and, as such, making changes to this copy will have absolutely no
impact on the generated text buffer.

#### ***IsOutputFileWritten***

```csharp
bool IsOutputFileWritten { get; }
```

This property is set to *false* when the ***TextTemplateConsoleBase*** class is initialized. It gets set to *true* when the contents of the generated
text buffer are written to the output file. The property will get set back to *false* on any of the following conditions:

- A *Segment* from the current text template file is processed to generate text that gets appended to the generated text buffer
- A new text template file is loaded and parsed
- The [***ResetAll***](#resetall) method is invoked

#### ***IsTemplateLoaded***

```csharp
bool IsTemplateLoaded { get; }
```

This property is set to *false* when the ***TextTemplateConsoleBase*** class is initialized. It gets set to *true* when a valid text template file
containing one or more segments gets loaded and parsed. After that, it will only ever be set back to *false* under two conditions:

- An attempt is made to load a text template file using an invalid file path
- The [***ResetAll***](#resetall) method is invoked

#### ***LineNumber***

```csharp
int LineNumber { get; }
```

When a text template file is loaded and parsed, the current line number being parsed is stored in the ***LineNumber*** property. When a *Segment* from
a text template is being processed to generate the output file, the ***LineNumber*** property is set to the number of each text line as it is
processed in that *Segment*. The following example should clarify this.

```
| PARSING | GENERATING |                     |
| LINE #  | LINE #     | TEXT TEMPLATE LINES |
| ------- | ---------- | ------------------- |
|     1   |            | /// Comment line    |
|     2   |            | ### Segment1        |
|     3   |            | /// Comment line    |
|     4   |      1     | @+1 Text line       |
|     5   |            | ### Segment2        |
|     6   |      1     | @+1 Text line       |
|     7   |            | /// Comment line    |
|     8   |      2     |     Text line       |
|     9   |            | ### Segment3        |
|    10   |      1     |     Text line       |
|    11   |      2     | @+1 Text line       |
```

> [!NOTE]
> *Every line of a text template file is counted when the file is read in and parsed. During the generation of the output file, however, only text lines
> are counted. Segment header lines and comment lines are not counted. The line counter gets reset every time [***GenerateSegment***](#generatesegment)
> is called to generate another segment.*

#### ***OutputDirectory***

```csharp
string OutputDirectory { get; }
```

The ***OutputDirectory*** property gets the full directory path where the generated text files will be written to. This property defaults to an empty
string. The desired output directory path must be set by calling the [***SetOutputDirectory***](#setoutputdirectory) method.

Example:

```csharp
public class MyTextProcessor : TextTemplateConsoleBase
{
    public MyTextProcessor()
    {
        SetOutputDirectory(@"C:\test\generatedText");
    }

    public void DoSomething()
    {
        // Returns "C:\test\generatedText"
        string outputDirectory = OutputDirectory;
    }
}
```

#### ***SolutionDirectory***

```csharp
string SolutionDirectory { get; }
```

The ***SolutionDirectory*** property returns the full directory path of the **Visual Studio** solution where the custom ***Text Template Processor***
console app is located. An empty string will be returned if the solution directory couldn't be located. (Refer to the description of the
[***Constructor***](#constructor), above, for more details.)

For the following example assume that the *MyApp.sln* file is located in this directory: `C:\Users\JohnDoe\Source\Repos\MyApp` And the
*MyTemplateApp.exe* console app was run from this directory: `C:\Users\JohnDoe\Source\Repos\MyApp\MyTemplateApp\bin\Debug\net6.0-windows`

```csharp
public class MyTemplateApp : TextTemplateConsoleBase
{
    public MyTemplateApp()
    {
    }

    public void DoSomething()
    {
        // Returns "C:\Users\JohnDoe\Source\Repos\MyApp"
        string solutionDirectory = SolutionDirectory;
    }
}
```

#### ***TabSize***

```csharp
int TabSize { get; }
```

The ***TabSize*** property retrieves the current tab size value. This value gives the number of spaces that make up a single tab stop. The tab size is
set to a default value of 4 when the ***TextTemplateConsoleBase*** class is initialized. This property only allows for retrieving the current value.
The [***SetTabSize***](#settabsize) method must be used if you want to change the tab size value.

#### ***TemplateFileName***

```csharp
string TemplateFileName { get; }
```

This property retrieves the file name of the text template file. This property is set to an empty string by the default constructor of the
***TextTemplateConsoleBase*** class. It will also be set to an empty string if an invalid file path is passed into the
[***LoadTemplate***](#loadtemplate) method.

#### ***TemplateFilePath***

```csharp
string TemplateFilePath { get; }
```

This property retrieves the full file path of the text template file. This property is set to an empty string by the default constructor of the
***TextTemplateConsoleBase*** class. It will also be set to an empty string if an invalid file path is passed into the
[***LoadTemplate***](#loadtemplate) method.

### Methods
#### ***ClearOutputDirectory***

```csharp
void ClearOutputDirectory()
```

The ***ClearOutputDirectory*** method deletes all files and folders existing in the output directory that was set by the
[***SetOutputDirectory***](#setoutputdirectory) method. It first checks to ensure that the output directory has been set (that is, it is not an empty
string).

#### ***GenerateSegment***

```csharp
void GenerateSegment(string segmentName, Dictionary<string, string>? tokenValues = null)
```

The ***GenerateSegment*** method processes the text lines for the specified segment name and generates new text lines that are appended to the
generated text buffer.

The *segmentName* argument must specify the name of a segment in the text template file. The optional *tokenValues* argument must be a dictionary of
key/value pairs where the key is a token name and the value is the token value to be substituted for the given token name.

For example, assume the text template file contains the following segment:

```
### Segment1
    Text line <#Token1#>
@+1 Text <#Token2#> 2
```

Your custom token processor app might contain code for processing this segment that looks like this:

```csharp
public class MyTemplateProcessor : TextTemplateConsoleBase
{
    public MyTextTemplateProcessor()
    {
        SetOutputDirectory("generated");
    }

    public void GenerateSegment1()
    {
        Dictionary<string, string> tokenValues = new()
        {
            { "Token1", "1" },
            { "Token2", "line" }
        };

        GenerateSegment("Segment1", tokenValues);
    }
}
```

When you invoke your ***GenerateSegment1*** method, the following lines will be appended to the end of the generated text buffer (assuming the current
indent position is 0 to start with):

```
Text line 1
    Text line 2
```

> [!NOTE]
> *The token values that are supplied to the **GenerateSegment** method are saved by the **Text Template Processor** class library. If you later
> call **GenerateSegment** for another segment that has some of the same token names then you would need to supply token
> values only for any new token names or for previous token names that have changed values.*

Before processing any text lines, the ***GenerateSegment*** method will take care of processing any segment options that may be defined on the
specified *Segment*. Suppose we have a *Segment* named **Segment1** which specifies a pad segment named **PadSegment**, a first time indent value of
1, and a tab size value of 2. The following steps will be taken in the order given each time ***GenerateSegment*** is called for **Segment1**:

1. The text lines for **PadSegment** will be generated and appended onto the end of the generated text buffer. (Note that this happens only on the
   second and subsequent times that ***GenerateSegment*** is called for **Segment1**.)
1. The tab size will be set to 2 spaces.
1. Each text line for **Segment1** will be processed in the order they were defined in the template file. For each text line:
   a. Determine the indent amount for the text line. Note that the first time ***GenerateSegment*** is called for **Segment1**, the indent amount of
      the first text line is determined from the first time indent value on the segment header. All other times the indent amount is determined from
      the tab control code on the corresponding template line.
   a. Replace all token placeholders on the text line with their respective token values.
   a. Add the required number of spaces to the beginning of the generated text line. The number of spaces is equal to the indent amount that was
      determined earlier.
   a. Append the resulting string to the end of the generated text buffer.

#### ***LoadTemplate***

```csharp
void LoadTemplate(string filePath)
```

As the name implies, the ***LoadTemplate*** method loads a text template file into memory and parses it so that it can be processed. The contents of
the template file are validated during the loading process and any errors that are detected result in appropriate error messages being written to the
log. The names of all tokens are also determined and saved for later use.

The *filePath* parameter is an absolute or relative file path for the text template file that is to be loaded. If a relative file path is specified,
then the file path is assumed to be relative to the value of the [***SolutionDirectory***](#solutiondirectory) property.

The following example assumes the ***SolutionDirectory*** property is currently set to `C:\Users\JohnDoe\Source\Repos\MyApp`.

```csharp
public class MyTemplateApp : TextTemplateConsoleBase
{
    public MyTemplateApp()
    {
    }

    public void DoSomething()
    {
        // Loads the template file located at file path
        // "C:\Users\JohnDoe\Source\Repos\MyApp\Templates\MyTemplate.txt"
        LoadTemplate(@"Templates\MyTemplate.txt");
    }
}
```

#### ***PromptUserForInput***

```csharp
string PromptUserForInput(string message = MsgContinuationPrompt)
```

The ***PromptUserForInput*** method allows for user interaction in the file generation process.

The optional *message* parameter can be used to specify a prompt message to be displayed on the console for the user to respond to. If no message is
given, the default message `Press [ENTER] to continue...` will be displayed.

The method returns whatever the user types in the console. Here's an example of how this method is used:

```csharp
public class MyTemplateApp : TextTemplateConsoleBase
{
    public MyTemplateApp()
    {
    }

    public void DoSomething()
    {
        string response = PromptForUserInput("Generate the debug segment? (Y or N)");

        if (response.ToUpper() == "Y")
        {
            GenerateSegment("DebugSegment");
        }
    }
}
```

#### ***ResetAll***

```csharp
void ResetAll(bool shouldDisplayMessage = true)
```

The ***ResetAll*** method is used to reset the state of the ***TextTemplateConsoleBase*** class object.

This method performs the following tasks:
- Clears the contents of the generated text buffer
- Removes the currently loaded template from memory
- Resets the current indent amount to 0
- Resets the tab size to its default value of 4
- Resets the token delimiters and escape character back to their default values (if they were changed)
- Sets the [**IsTemplateLoaded**](#istemplateloaded) and [**IsOutputFileWritten**](#isoutputfilewritten) properties to *false*

The optional *shouldDisplayMessage* parameter determines whether or not a message gets logged at the end of the reset process. The default is *true*
(a message is logged). The message can be suppressed by passing *false* into the method.

> [!NOTE]
> *You would normally only use the **ResetAll** method after you're done processing one text template file and want to process a different one.
> However, **ResetAll** is called automatically whenever a new text template file is loaded.*

#### ***ResetGeneratedText***

```csharp
void ResetGeneratedText(bool shouldDisplayMessage = true)
```

The ***ResetGeneratedText*** method is used to clear the generated text buffer.

This method performs the following tasks:
- Clears the contents of the generated text buffer
- Resets the current indent amount to 0
- Resets the tab size to its default value of 4
- Sets the [**IsOutputFileWritten**](#isoutputfilewritten) property to *false*
- Resets the state of each *Segment* in the text template file (see the [***ResetSegment***](#resetsegment) method below for details)

The optional *shouldDisplayMessage* parameter determines whether or not a message gets logged at the end of the reset process. The default is *true*
(a message is logged). The message can be suppressed by passing *false* into the method.

The ***ResetGeneratedText*** method is normally called after you have written the contents of the generated text buffer to an output file. (See the
[***WriteGeneratedTextToFile***](#writegeneratedtexttofile) method.) You can then reprocess the same text template to generate another file (using
different token values, for example).

> [!NOTE]
> *The [**WriteGeneratedTextToFile**](#writegeneratedtexttofile) method automatically calls the **ResetGeneratedText** method by default after the
> output file has been written. So normally there isn't a need to explicitly call the **ResetGeneratedText** method.*

#### ***ResetSegment***

```csharp
void ResetSegment(string segmentName)
```

The ***ResetSegment*** method is used to reset the state of the specified segment.

The *segmentName* parameter specifies the name of the segment that is to be reset.

As mentioned earlier in this document, the first time [***GenerateSegment***](#generatesegment) is called for a given segment the **FTI** (*First Time
Indent*) option is handled if that option was specified on the segment header. The second and subsequent times ***GenerateSegment*** is called for
that segment the **PAD** option is handled if that option was specified on the segment header.

When a segment is reset it starts this sequence all over again. The **FTI** option will be handled the next time ***GenerateSegment*** is called for the
given segment, and the **PAD** option will be handled every time ***GenerateSegment*** is called after that.

For an example of why you might want to do this, consider a public class that contains an embedded private class. Both classes have properties defined
on them. The text template file used for generating this class will likely have a segment used for generating those properties. The segment also will
likely make use of the **FTI** and **PAD** options for formatting the properties. In this situation it would make sense to call the ***ResetSegment***
method on the property segment after generating all the properties for the public class and before generating the properties for the private class to
ensure that they are both formatted correctly.

#### ***ResetTokenDelimiters***

```csharp
void ResetTokenDelimiters()
```

The ***ResetTokenDelimiters*** method resets the token start and token end delimiters and the token escape character to their default values of `<#`,
`#>`, and `\`, respectively. (See also the [***SetTokenDelimiters***](#settokendelimiters) method.)


> [!NOTE]
> *Normally the **ResetTokenDelimiters** method would be called only after processing one text template file and before processing a different text
> template file where the first file uses delimiters different than the default delimiters and the second one uses the default. Keep in mind, though,
> the **ResetTokenDelimiters** method is called automatically by the [**ResetAll**](#resetall) method whenever a new template file is loaded.*

#### ***SetOutputDirectory***

```csharp
void SetOutputDirectory(string directoryPath)
```

The ***SetOutputDirectory*** method sets the directory path where generated text files will be written to.

The *directoryPath* parameter specifies an absolute or relative directory path where generated text files are to be written to. If a relative
directory path is specified, then the directory path is assumed to be relative to the value of the [***SolutionDirectory***](#solutiondirectory)
property. If the specified file path doesn't exist, then it will be created.

> [!NOTE]
> *The [**OutputDirectory**](#outputdirectory) property sill be set to the directory path determined by this method.*

The following example assumes the ***SolutionDirectory*** property is currently set to `C:\Users\JohnDoe\Source\Repos\MyApp`.

```csharp
public class MyTemplateApp : TextTemplateConsoleBase
{
    public MyTemplateApp()
    {
    }

    public void DoSomething()
    {
        // The OutputDirectory property will be set to
        // "C:\Users\JohnDoe\Source\Repos\MyApp\generated"
        SetOutputDirectory("generated");
    }
}
```

#### ***SetTabSize***

```csharp
void SetTabSize(int tabSize)
```

The ***SetTabSize*** method simply sets the tab size to the specified value.

The *tabSize* parameter specifies the new value for the tab size. It must be an integer value between 1 and 9, inclusive. The default value is 4.

Once the tab size has been changed, all future indentation of the lines written to the generated text buffer will be based on this new value. For
example, if you change the value from 4 to 2, and then generate a text line that specifies a tab value of 1, the line will be indented 2 spaces to the
right instead of 4 from the current indent position.

#### ***SetTokenDelimiters***

```csharp
bool SetTokenDelimiters(string tokenStart, string tokenEnd, char tokenEscapeChar)
```

The ***SetTokenDelimiters*** method allows you to specify token start and end delimiters and token escape character that differ from the default values
of `<#`, `#>`, and `\`, respectively.

The *tokenStart* and *tokenEnd* parameters must specify strings of one or more characters, whereas the *tokenEscapeChar* parameter must be a single
character. The *tokenStart* and *tokenEnd* parameter values must not be the same and must not match the *tokenEscapeChar* parameter.

The ***SetTokenDelimiters*** method is useful only in cases where the default delimiters may cause confusion or other issues in the text template
file. For example, maybe the string `<#` appears repeatedly in the template file as normal text. Rather than forcing you to escape all instances of
this string where it isn't the start of a token, you can instead choose to use a different string, such as `<{` for the token start delimiter and `}>`
for the token end delimiter. You would then call ***SetTokenDelimiters*** in your custom template processor class prior to loading the template into
memory.

Here's an example of how ***SetTokenDelimiters*** might be called:

```csharp
public class MyTemplateProcessor : TextTemplateConsoleBase
{
    public MyTemplateProcessor()
    {
    }

    private void LoadMyTemplate()
    {
        SetTokenDelimiters("<{", "}>", '\\');
        LoadTemplate(@"C:\Templates\MyTemplate.txt");
    }
    ...
}
```
<br>

> [!IMPORTANT]
> *You must call **SetTokenDelimiters** to set the correct delimiter values before calling [**LoadTemplate**](#loadtemplate) to load the text template
> file that is using those delimiter values.*

#### ***WriteGeneratedTextToFile***

```csharp
void WriteGeneratedTextToFile(string filePath, bool resetGeneratedText = true)
```

The ***WriteGeneratedTextToFile*** method is used for writing the contents of the generated text buffer to the output file.

The required *filePath* parameter specifies an absolute or relative file path for the generated text output file. If a relative file path is
specified, then it is assumed to be relative to the value of the [***OutputDirectory***](#outputdirectory) property.

The optional *resetGeneratedText* parameter specifies whether or not the generated text buffer should be cleared after its contents are written to the
output file. The default if this parameter is omitted is *true* (the buffer will be cleared).

> [!IMPORTANT]
> *The output directory path must be set by calling the [**SetOutputDirectory**](#setoutputdirectory) method prior to calling the
> **WriteGeneratedTextToFile** method.*

The following example assumes that the generated text buffer isn't empty when the ***WriteGeneratedTextToFile*** method is called and the
***SolutionDirectory*** property is currently set to `C:\Users\JohnDoe\Source\Repos\MyApp`.

```csharp
public class MyTemplateApp : TextTemplateConsoleBase
{
    public MyTemplateApp()
    {
        // The OutputDirectory property will be set to
        // "C:\Users\JohnDoe\Source\Repos\MyApp\generated"
        SetOutputDirectory("generated");
    }

    public void DoSomething()
    {
        // The generated text buffer will be written to
        // "C:\Users\JohnDoe\Source\Repos\MyApp\generated\MyFile.cs"
        // and then the generated text buffer will be cleared.
        WriteGeneratedTextToFile("MyFile.cs");
    }
}
```